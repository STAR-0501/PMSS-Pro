{
    "first": "物理模拟系统API规范:1.坐标系:屏幕左上(0,0),y轴向下为正,所有位置参数必须用Vector2封装 2.元素控制:只能通过game.elements字典操作,添加元素需双通道写入all和类型列表 3.环境参数:使用game.setAttr('gravity',9.8)设置 4.视图控制:game.x平移坐标系,game.ratio缩放比例 5.坐标转换:必须使用game.screenToReal()将屏幕坐标转为真实坐标 6.数值规范:颜色用字符串,质量/半径保留1位小数 7.错误处理:必须用try-except包裹代码并打印具体错误 8.严格禁止:import其他模块、修改game对象外的变量",
    "second": "坐标转换核心方法:realToScreen和screenToReal。所有位置操作必须显式使用转换方法,并自动补偿位移。",
    "third": "元素添加操作规范:python复制# 元素添加必须遵守的双通道写入规则def add_element(element, element_type):    '''同时写入all列表和类型列表的原子操作'''    game.elements['all'].append(element)      # 全局列表    game.elements[element_type].append(element) # 类型专属列表# 错误示例修正# ❌ 危险写法:只写入类型列表game.elements['ball'].append(new_ball)# ✅ 正确写法:双通道写入add_element(new_ball, 'ball')强化约束条件原子性保证:必须通过封装函数或同步操作确保两个列表的一致性类型校验:添加前验证element.type与目标列表是否匹配异常回滚:若任一添加操作失败,需移除已添加的残留数据增强示例python复制# 示例:'在(150,300)屏幕坐标创建质量为20的绿色小球'try:    # 坐标转换    screen_pos = Vector2(150, 300)    real_x = game.screenToReal(screen_pos.x, game.x)    real_y = game.screenToReal(screen_pos.y, game.y)        # 创建实例    new_ball = Ball(        position=Vector2(real_x, real_y),        radius=15.0,        color='#00ff00',        mass=20.0,        velocity=Vector2(0,0)    )        # 原子化添加(使用封装函数)    def safe_add(element):        if element.type not in game.elements:            raise ValueError(f'非法类型 {element.type}')        game.elements['all'].append(element)        game.elements[element.type].append(element)        safe_add(new_ball)    except ValueError as ve:    print(f'类型错误: {str(ve)}')except IndexError as ie:    game.elements['all'] = [e for e in game.elements['all'] if e != new_ball]  # 回滚    game.elements['ball'] = [b for b in game.elements['ball'] if b != new_ball]    print(f'索引错误: {str(ie)}')except Exception as e:    print(f'未知错误: {str(e)}')列表同步机制python复制# 删除操作同样需要双通道def remove_element(element):    if element in game.elements['all']:        game.elements['all'].remove(element)    if element.type in game.elements:        if element in game.elements[element.type]:            game.elements[element.type].remove(element)# 移动模式切换时的同步def switch_mode(is_celestial):    current_elements = game.celestialElements if is_celestial else game.groundElements    # 深度拷贝保证数据隔离    game.elements = {        'all': [e.copy() for e in current_elements['all']],        'ball': [b.copy() for b in current_elements['ball']],        'wall': [w.copy() for w in current_elements['wall']]    }动态校验规则python复制# 在每次添加/删除后执行校验def validate_integrity():    all_count = len(game.elements['all'])    type_counts = sum(len(lst) for k,lst in game.elements.items() if k != 'all')        if all_count != type_counts:        print(f'数据不一致！总列表:{all_count} 类型列表合计:{type_counts}')        # 自动修复逻辑        game.elements['all'] = []        for t in [k for k in game.elements.keys() if k != 'all']:            game.elements['all'].extend(game.elements[t])该补充规范通过以下机制确保数据一致性:双通道写入:通过封装函数强制保证all列表与类型列表同步事务性操作:使用try-except-rollback模式实现原子性定期校验:通过validate_integrity()自动检测数据一致性深度拷贝隔离:模式切换时创建元素副本,避免引用冲突",
    "fourth": "AI代码生成安全规范(防eval错误版)输出格式约束严格禁止Markdown语法:python复制# ❌ 错误输出```pythonprint('Hello')✅ 正确输出print('Hello')复制去除所有注释符号:python复制# ❌ 错误输出# 这是一条注释print('Hello')# ✅ 正确输出print('Hello')确保纯代码输出:python复制# ❌ 错误输出代码开始:print('Hello')复制# ✅ 正确输出print('Hello')安全生成规则python复制# 1. 确保代码可独立运行def generate_safe_code(command):    # 预处理:去除所有非代码内容    code = remove_non_code_content(command)        # 校验:确保是合法Python代码    if not is_valid_python(code):        raise ValueError('生成内容不是合法Python代码')        # 返回:纯代码字符串    return code# 2. 示例安全生成逻辑def create_ball_safely(x, y):    return f'''try:    pos = Vector2({x}, {y})    game.elements['all'].append(Ball(pos, 30.0, 'red', 50.0, Vector2(0,0)))    game.elements['ball'].append(game.elements['all'][-1])except Exception as e:    print(f'创建失败: {{str(e)}}')'''错误处理增强python复制# 1. 预检查机制def precheck_code(code):    try:        compile(code, '<string>', 'exec')        return True    except SyntaxError:        return False# 2. 安全执行封装def safe_eval(code):    if not precheck_code(code):        raise ValueError('代码语法检查失败')        try:        exec(code, {'game': game, 'Vector2': Vector2})    except Exception as e:        print(f'执行错误: {str(e)}')示例安全输出python复制# 用户指令:'在(100,200)创建红色小球'# AI应生成:try:    screen_pos = Vector2(100, 200)    real_x = game.screenToReal(screen_pos.x, game.x)    real_y = game.screenToReal(screen_pos.y, game.y)    new_ball = Ball(Vector2(real_x, real_y), 30.0, 'red', 50.0, Vector2(0,0))    game.elements['all'].append(new_ball)    game.elements['ball'].append(new_ball)except Exception as e:    print(f'创建失败: {str(e)}')防注入措施python复制# 1. 禁用危险操作BANNED_KEYWORDS = ['import', 'exec', 'eval', 'open', '__']def is_code_safe(code):    for keyword in BANNED_KEYWORDS:        if keyword in code:            return False    return True# 2. 执行前检查def execute_safely(code):    if not is_code_safe(code):        raise ValueError('检测到危险操作')    safe_eval(code)集成方案预处理层:去除Markdown标记、注释等非代码内容语法检查层:使用compile预编译验证语法安全过滤层:禁用危险关键字和操作执行封装层:通过safe_eval限制执行环境测试用例python复制# 测试1:合法代码code = '''try:    pos = Vector2(100, 200)    game.elements['all'].append(Ball(pos, 30.0, 'red', 50.0, Vector2(0,0)))    game.elements['ball'].append(game.elements['all'][-1])except Exception as e:    print(f'创建失败: {str(e)}')'''assert precheck_code(code) == True# 测试2:危险代码danger_code = '''import osos.system('rm -rf /')'''assert is_code_safe(danger_code) == False通过以上机制,可确保AI生成的代码:完全兼容eval执行无语法错误无安全风险符合项目数据结构要求",
    "fifth": "必须严格检查python语句语法,不得出现括号,引号未闭合等低级错误!!!这是非常重要的一点",
    "sixth": "创建对象和调用方法时请检查每个类或方法应该提供哪些属性,不能出现问题属性缺失或类型错误等错误,特别是artificialForces等容易忽略的属性。",
    "seventh": "屏幕定位: 屏幕左上角为(0,0),y轴向下为正,所有位置参数必须用Vector2封装。可以通过修改game.x和game.ratio来实现缩放和平移。甚至接合遍历实体列表,可以实现精准的屏幕定位到实体位置。",
    "eighth": "如果执行成功，应该在返回的代码中打印出执行结果。",
    "ending": "前面说到的每个点，都是你必须严格遵守的编程规范，不遵守这些规范，将导致程序崩溃的严重后果！！！"
    
}